% This file was created by wordml2latex version 1.0, Copyright (C) 2005 Ruggero Dambra
% wordml2latex comes with ABSOLUTELY NO WARRANTY; for details read wordml2latex.pdf.
% This is free software, and you are welcome to redistribute it under certain conditions; read wordml2latex.pdf for details.



\documentclass[12pt,english,a4paper]{article}
\usepackage[]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[top=2.495687986201556cm,bottom=1.4977647928473372cm,left=2.9937695800626564cm,right=1.9958463867084377cm]{geometry}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{eurosym}
\usepackage{amsmath}
\usepackage{color}
\usepackage{fancyhdr}
\usepackage{hyperref}
\hypersetup{pdftitle={Framework de localização passiva por Bluetooth na},pdfsubject={Relatório do Estágio Curricular da LEIC 2006/07},pdfkeywords={},pdfauthor={Paulo Jorge Duarte Köch},pdfcreator={wordml2latex (by Ruggero Dambra, http://www25.brinkster.com/ruggdam)}, colorlinks=true, linkcolor=red, anchorcolor=black, citecolor=green, filecolor=magenta, menucolor=red, pagecolor=red, urlcolor=blue, breaklinks=true, pdfstartview=FitH, pdfpagemode=UseOutlines}

\title{Framework de localização passiva por Bluetooth na}
\author{Paulo Jorge Duarte Köch}
\date{20/09/2007}

\newcommand{\wl}{{\sffamily WordML}{\Large 2}\LaTeX{}}

\begin{document}\label{_Ref31804427}

\fbox{
\begin{minipage}{15.965011088035483cm}
\begin{center}
{\textbf{Faculdade de Engenharia da Universidade do Porto}}
\end{center}
\begin{center}
{\textbf{Licenciatura em Engenharia Informática e Computação}}
\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}
\fbox{
\begin{minipage}{90pt}
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a binary object named ``06 copy''}}
\end{minipage}
}
\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}
{\textbf{{\large Framework de }}\textbf{{\large Localização P}}\textbf{{\large assiva por Bluetooth}}\textbf{{\large  na}}\textbf{{\large }}\textbf{{\large Novabase / Octal }}\textbf{{\large 2 }}\textbf{{\large Mobile}}}
\end{center}
\begin{center}

\end{center}
\begin{center}
{\textbf{{\footnotesize Relatório do Estágio Curricular da LEIC }}\textbf{{\footnotesize 2006/07}}}
\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}
\emph{Paulo Jorge Duarte Köch}
\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}
{{\footnotesize Orientador na FEUP: Prof. }{\footnotesize João Correia Lopes}}
\end{center}
\begin{center}
{{\footnotesize Orientador na }{\footnotesize Novabase / Octal }{\footnotesize 2 }{\footnotesize Mobile}{\footnotesize : }{\footnotesize Eng. }{\footnotesize João Vasco Ranito}}
\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}
{{\footnotesize Setembro}{\footnotesize  de 2007}}
\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\begin{center}

\end{center}
\end{minipage}}

Imagine-se um dispositivo Bluetooth a ser localizado, apelidado de ``Rover'', com nenhum ou muito pouco software específico, dentro de uma área aonde está instalada uma grelha de vários outros dispositivos de Bluetooth, apelidados de ``Beacons''. Os Beacons são estacionários, é conhecida a sua localização, e estão ligados a um computador central. O Rover é transportado por uma pessoa e, por isso, assume-se que tem liberdade de movimentos total.

O objectivo deste estágio era construir uma plataforma que dote a grelha de Beacons com a capacidade de localizar o Rover quando este se encontra dentro da grelha.

RESUMIR O RESTO DO CONTEÚDO DO DOCUMENTO.

Agradeço a todas as pessoas da Novabase que toleraram coabitar comigo o meu local de trabalho, distraindo-me e ajudando-me sempre que precisei. Obrigado Daniel Carneiro, Ricardo Afonso, Hugo Barrote, Mário Couto e João Cavadas.

Agradeço aos meus orientadores por todo o trabalho que envergaram e por todas as vezes que discutiram comigo, trazendo-me sempre à terra. Obrigado João Correia Lopes e João Vasco Ranito.

Agradeço à FEUP por todo o meu percurso académico que culminou com a oportunidade de fazer parte de uma equipa de vida real, com problemas de vida real, dando-me experiência de vida real. Obrigado, comunidade FEUP e instituição FEUP.

\textcolor[rgb]{1,0,0}{Agradecer o financiamento do PRODEP (saber junto do secretariado da LEIC qual é o número do projecto PRODEP), caso aplicável.}
\tableofcontents

{\textbf{{\tiny }}}

\part{Introdução}


\section{O projecto: Framework de localização passiva por Bluetooth}


\subsection{Contextualização e motivação}


Desde sempre que o Homem tem a necessidade de comunicar e tem sido um aspecto de interesse permanente. Começou-se pela expressão corporal e sonora. Inventou-se a comunicação por símbolos, a fala e a escrita. Apareceu também a ``telecomunicação'', comunicação à distancia. O telégrafo foi um dos primeiros instrumentos de telecomunicação. Seguiu-se o telefone e o telemóvel.

Os telemóveis, invenção relativamente recente, têm sido dotados de cada vez mais capacidades. Ao que era apenas um telefone sem fios, foi-se acrescentando imensa funcionalidade: gestão de contactos, gestão de agenda, leitor de música digital, etc{\ldots} Actualmente, com a adição de tanta funcionalidade, o conceito de telemóvel está a mudar. 

Estamos a assistir à fusão entre telemóveis e computadores pessoais, reunindo num só dispositivos a capacidade de gerir e transformar informação, vindo do lado dos computadores, à capacidades de comunicar informação, vindo do lado dos telemóveis. Estes novos dispositivos chamam-se Assistentes Pessoais Digitais, embora sejam mais conhecidos pelo acrónimo em inglês, PDA (\emph{Personal Digital Assistant}\emph{)}.

Com toda esta funcionalidade, tem-se vindo a revelar o desejo de que estes aparelhos, sejam PDAs ou os telemóveis mais recentes, comuniquem entre si e possam partilhar informações. O \emph{Bluetooth} veio servir esta necessidade. \emph{Bluetooth}, também conhecido como BT, é uma tecnologia de comunicação de dados que funciona sobre ondas rádio, permitindo transferências de informação entre dispositivos de forma cómoda e simples.

As ondas rádio, como as que são usadas pelo BT, são propagadas pelo ar e podem sofrer de alterações e atenuações durante a propagação. Por isso, podem ser ``sentidas'' com mais ou menos força pelos intervenientes nessa comunicação. Um aparelho interveniente nesta comunicação precisa de estar consciente da força com que vê a onda para pedir aos seus pares para a regularem conforme necessário. Numa situação simples onde não haja obstáculos na propagação das ondas, o único factor de atenuação é a distância que a onda tem de percorrer. Se um par de dispositivos a comunicar por BT se distanciar um do outro progressivamente, terão de emitir as ondas rádio com cada vez mais força para que estas cheguem adequadamente ao seu destino.

É plausível afirmar que há alguma relação entre a força de sinal da comunicação entre dois dispositivos e a distância entre eles. Se um dos dispositivos for fixo, de localização conhecida, e o outro móvel,  podemos usar esta correlação para determinar a que distância o dispositivo móvel se encontra do fixo. Se três dispositivos fixos souberem esta distância, podemos saber a posição do dispositivo móvel.

Isto vai de encontro ao interesse do nosso telemóvel/PDA saber onde se encontra e poder, potencialmente, utilizar essa informação. Por exemplo, mudar o volume do aviso de chamada caso o telemóvel se encontra numa sala de reuniões, bloquear o nosso computador quando nos afastamos dele, só para nomear alguns usos.

\subsection{Objectivo}


O objectivo geral deste estágio é desenhar um sistema para localização de um aparelho, apoiando-se na correlação entre propriedades dos sinais trocados e a distância. Depois de desenhado o sistema, também se pretende implementar um protótipo como demonstração de conceito.

A ideia inicial deste sistema é, num espaço amplo, instalar vários dispositivos BT fixos, formando uma grelha estática e bem conhecida. Cada dispositivo fixo chama-se ``Beacon''. Um Beacon é estacionário, é conhecida a sua localização, e todos estão ligados a um computador central. Além dos Beacons, é considerado outro tipo de dispositivos, os ``Rovers''. Um Rover é um dispositivo BT a ser localizado, conhecido de antemão e é, em principio, transportado por uma pessoa.

Tendo a grelha instalada, os Beacons procuram constantemente pela presença de Rovers. Quando um Beacon encontra um Rover\footnote{ Um Beacon ``encontra'' um Rover quando se consegue ligar a ele. }, mede das propriedades dos sinais com que é feita a comunicação e informa o computador central dessa medida. O computador central fica então responsável por deduzir informação sobre a localização dos Rovers, a partir das propriedades dos sinais que lhe foram comunicadas pelos vários Beacons. 

O sistema como um todo é composto pela grelha de Beacons e pelo \emph{software} de dedução de localização.

De uma forma mais específica, os objectivos do estágio são, por ordem:
\begin{enumerate}
\item Averiguar as medidas que o Bluetooth proporciona, as que sejam passiveis de serem utilizadas como base do sistema de localização;
\item Formular um sistema que use essas medidas;
\item Implementar esse sistema;
\item Confirmar a validade do sistema com testes; e
\item Determinar a precisão/exactidão conseguidas,
\end{enumerate}
\end{enumerate}

\section{A instituição: Novabase / Octal 2 Mobile}


A \emph{Novabase / Octal }\emph{2 }\emph{Mobile} é uma empresa que pertence à divisão \emph{Engineering} do grupo \emph{Novabase}. Foi criada com o objectivo de fornecer serviços em dispositivos móveis.

Na altura da sua concepção, ainda não havia proliferação suficiente para que este fosse um negócio sustentável. Por isso, antes de fornecer serviços, foi preciso criar uma base de utilizadores de \emph{PDAs} razoável. Desde então, em segundo plano, foi-se acumulando \emph{know-how} dentro da empresa, facilitando assim o objectivo primordial.

Neste momento, a empresa encontra-se num ponto de viragem. O negócio da distribuição é mantido mais pelo volume de negócios que gera do que por interesse estratégico. Agora que há a base de utilizadores desejada, a aposta no fornecimento de serviços começa a ganhar momento e importância.

\section{O projecto na instituição}


Como a empresa está num ponto de viragem, há que capitalizar as tecnologias existentes nos equipamentos móveis com o intuito de gerar valor acrescentado para conseguir penetração no mercado de serviços. Se considerarmos que quase todos os PDAs têm BT, aproveitando os frutos deste projecto, a empresa terá à sua disposição uma ferramenta que servirá como forte base de apoio para a criação de um leque de novos produtos, gozando tanto de uma facilidade acrescida em diminuir o \emph{Time }\emph{To }\emph{Market} como de acumulação de \emph{know-how}.

\section{O documento: estrutura e conteúdo}


Este documento está dividido em três grandes partes: apresentação do problema, explanação da estratégia para implementação da solução e resultados e conclusões.

A apresentação do problema é feita a três tempos. Primeiro, na introdução, tenta-se contextualizar o leitor e apresentar de forma simples o problema. No capítulo \ref{_Ref177384068}\ref{_Ref177384090} é dado a conhecer o estado da arte, a maneira como outros tentaram resolver este mesmo problema e quais os resultados a que chegaram. De todos os artigos relevantes, são destacados aqueles que documentam métodos ou aferições de forma concreta.

A explanação da estratégia e implementação da solução consistem em duas partes. No quarto capítulo será exposta a arquitectura da solução na sua totalidade. A análise é dividida na sua componente física e lógica. No quinto capítulo, é explicado o percurso da implementação da solução, os percalços encontrados e respectivas resoluções.

No sexto capítulo, serão descritos os frutos do trabalho desenvolvido. No sétimo capítulo, são apresentadas e discutidas conclusões finais e perspectivas futuras.



\part{O Problema: Radiolocalização por Bluetooth}
\label{_Ref177384068}
\begin{flushleft}
Neste capítulo será dado a conhecer ao leitor a definição completa do problema. Embora de forma sucinta, são apresentados os conceitos em que o problema assenta. Esta apresentação será devidamente guiada para que o leitor não tenha dificuldades em ler o resto do documento.


\section{Definição}


O problema é construir um sistema de radiolocalização passiva de aparelhos móveis apoiado em BT. O ambiente alvo é \textcolor[rgb]{NaN,NaN,NaN}{\emph{indoor}}. Pretende-se que a localização seja orientada à posição num local, e não à presença num local.

No sentido lato, radiolocalização é o acto de localizar a posição de um objecto com recurso a ondas rádio. Pode ser feita activamente ou passivamente. Activamente, o objecto analisa as ondas rádio presentes no meio para saber onde se encontra. Passivamente, as ondas rádio provenientes de um objecto são analisadas por um ou mais agentes exteriores para determinar a localização desse objecto [WC:Radiolocalização].

Os aparelhos BT a localizar, também denominados sujeitos ou Rovers, serão telemóveis/PDAs, sobre os quais não há controlo. Ou seja, nestes dispositivos não é possível fazer nenhuma alteração de \emph{hardware}. No máximo, o sistema pode requerer a instalação de algum \emph{software}, mas mesmo isso é indesejado. Pretende-se que o sistema consiga localizar qualquer tipo de telemóvel/PDA. No mínimo, é desejado que a solução funcione com dispositivos baseado em \emph{Windows Mobile}. Nos dispositivos de apoio, denominados observadores ou Beacons, temos liberdade total, desde o \emph{hardware} ao \emph{software}. No entanto, tenta-se evitar soluções ``exóticas''.

\section{Background}


Para dar um melhor entendimento do conceito, será explicado:
\begin{itemize}
\item A noção de localização de um objecto,
\item O funcionamento das comunicações rádio,
\item As técnicas de localização clássicas,
\item As técnicas de radiolocalização,
\item A tecnologia BT, \emph{Bluetooth}, e
\item A aplicação das várias técnicas de radiolocalização em BT.
\end{itemize}
\end{enumerate}



\subsection{Localização de um objecto}


A localização de um objecto é normalmente definida por uma posição. Uma posição é caracterizada por um conjunto de valores de coordenadas dentro de um sistema de coordenadas [WP:Position]. Um sistema de coordenadas é geralmente definido por um ponto de origem e vários eixos. Cada coordenada da posição é referente a um eixo e representa a distância nesse eixo do ponto em questão à origem do referencial [WP:CoordinateSystem]. Por exemplo, um dos sistemas mais conhecidos é o \emph{World}\emph{ }\emph{Geodetic}\emph{ }\emph{System} [WP:WGS], o sistema de coordenadas que usamos quando referimos coordenadas de longitude e latitude.

\subsection{Ondas rádio e comunicação rádio}


Ondas rádio são um caso particular de ondas electromagnéticas com frequência dentro do espectro das frequências de rádio (entre 3 Hz e 30 GHz) [WP:OndasDeRádio] [WP:RadioFrequency]. Uma onda electromagnética é um campo electromagnético que viaja no espaço, provocando oscilações de energia por onde passa [WP:RadiaçãoElectromagnética]. Convém ter em mente que as ondas podem ser alteradas durante o seu percurso, dependendo da matéria com que interagem. Por exemplo: ao atravessar um vidro deformado, uma onda pode mudar de direcção ou perder força; ao ``colidir'' com um determinado material, uma onda pode dissipar-se. São muitos os tipos de alterações a que uma onda é susceptível. A susceptibilidade de uma onda sofrer uma certa alteração depende das características da onda.

A comunicação por ondas rádio é feita por dois dispositivos: um que gera as ondas rádio e outro que consegue detectar quando é atravessado por elas. Se associarmos um símbolo a um conjunto de características de uma onda, cada vez que o receptor detecta uma onda com essas características a atravessá-lo, considera que o emissor lhe comunicou esse símbolo [WP:Radio]. Posto isto, podemos dizer que o sucesso de uma comunicação por ondas rádio depende de três factores: a capacidade do emissor gerar ondas, a capacidade do meio transportar as ondas de forma fiável e a capacidade do receptor reconhecer as ondas que o atravessam. Por norma, é fácil garantir um bom mecanismo de emissão e recepção, o que normalmente apresenta problemas é o meio de propagação do sinal.

\subsection{Localização clássica}


Historicamente, a localização é uma componente da navegação. Navegar é planear e executar uma viagem de um ponto de origem para um de destino. Durante a viagem, um dos actos mais importante é a localização. Localizar é determinar a posição a que um sujeito se encontra, normalmente para verificar que a viagem está a decorrer correctamente, aplicando as medidas correctivas necessárias [WP:Navigation].

A ``arte'' da localização foi evoluindo ao longo dos tempos. Começaram por ser usados esquemas simples, como o reconhecimento básico e a navegação estimada. Estes sempre foram usados, tanto por Humanos como outros animais, para conseguir navegar ao longo do seu meio envolvente. O reconhecimento básico envolve reconhecer ``algo'', seja um sítio ou um objecto estacionário. Assim que é encontrado esse ``algo'', podemos dizer que nos encontramos na proximidade dele. A navegação estimada é, sabendo a posição anterior, direcção do movimento, velocidade e diferença de tempo, estimar a posição actual. Nesta técnica podemos também substituir a velocidade e diferença de tempo por distância percorrida [WP:DeadReckoning].

Com o avanço no campo da matemática, apareceram as noções de trigonometria, dando origem aos conceitos de trilateração e triangulação. Apoiadas nestes dois conceitos, apareceram novas técnicas de localização. Uma das mais conhecidas é a navegação celestial, que recorre a sextantes [WP:Sextante] (ou equivalentes), à posição de certos corpos celestiais e à triangulação.

A triangulação permite-nos determinar a posição de um sujeito sabendo o ângulo a que ele se encontra de duas localizações conhecidas (para mais informação, consultar [WP:Triangulation]). 

























\fbox{
\begin{minipage}{453pt}
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a binary object named ``744px-Distance_by_triangulation''}}
\end{minipage}
}

Em contrapartida, a trilateração baseia-se em, pelo menos, três posições conhecidas e nas distâncias entre cada uma destas e o sujeito a ser localizado. Cada conjunto formado por uma posição conhecida e a distância ao sujeito, pode ser visto como um círculo centrado nesse ponto conhecido. A intersecção de três destes círculos é a posição do sujeito. A grande fraqueza deste método é apenas funcionar com valores perfeitos. Basta um pequeno erro em qualquer um dos valores para a solução se tornar impossível [WP:Trilateration].























\fbox{
\begin{minipage}{225pt}
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a binary object named ``300px-Trilateration''}}
\end{minipage}
}

Os métodos mais recentes de localização baseiam-se sobretudo na comunicação de ondas electromagnéticas. Um caso recente da aplicação de uma técnica de localização baseada em ondas electromagnéticas é o Sistema de Posicionamento Global, mais conhecido por GPS (acrónimo do nome em inglês, \emph{Global }\emph{Positioning}\emph{ }\emph{System} [WP:GPS]). Hoje em dia, este sistema é o \emph{standard de facto} em termos de localização.

\subsection{Os vários métodos de radiolocalização}


A descoberta das ondas electromagnéticas trouxe novas técnicas de localização. Embora haja um vasto leque de sistemas de localização, quase todos se baseiam num conjunto base de métodos, ou variações dos mesmos. Estes métodos são:
\begin{itemize}
\item Medição do ângulo de recepção do sinal,
\item Medição do tempo de voo da onda e,
\item Medição das alterações na onda ao longo do voo.
\end{itemize}
\end{enumerate}

A alteração mais considerada é a atenuação da onda. Seguidamente, cada um destes métodos será devidamente explicado, analisando as desvantagens de cada um dos métodos. Note-se que esta análise de contras é tendenciosa por ser feita, maioritariamente, sob o ponto de vista do problema a resolver.

\subsubsection{Ângulo de recepção}


A idealização do método parece simples: descobrir o ângulo de chegada em dois sítios para poder triangularizar. Há várias maneiras de o fazer. A mais simples é ter uma antena, em rotação constante e regular, que detecta sob qual direcção se recebe com mais força o sinal emitido pelo sujeito a localizar [WP:RadioDirectionFinder]. Isto pode ser feito de outras maneiras, por exemplo o uso de sistema do tipo Lorenz [WP:Lorenz(navigation)] ou outras descritas em [WP: AngleOfArrival].







\fbox{
\begin{minipage}{110.5pt}
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a binary object named ``NDB_Article_Airspace_Fix_Diagram''}}
\end{minipage}
}

A desvantagem mais óbvia é não ser exequível com antenas omnidireccionais simples.

\subsubsection{Tempo de voo}


Se soubermos os tempos absolutos que uma onda demorou a ir e vir, sabendo a velocidade de propagação no meio, podemos deduzir a distância. Se três receptores conhecidos conseguirem determinar estes tempos, podemos localizar o sujeito por trilateração.

A implementação deste método pode ser pensada de duas maneiras. Se o sujeito a localizar reflectir ondas electromagnéticas, podemos enviar uma onda e medir quanto tempo demora da emissão da onda inicial até à chegada da reflexão da onda. O maior problema aqui é a onda ser reflectida em algo que não o sujeito. Nesse caso estaríamos a medir algo que não o sujeito.

A outra implementação é ser o próprio sujeito a emitir uma onda. Aqui, o receptor não sabe quando é que a onda foi emitida, só sabe o tempo de chegada. Para ultrapassar isto, podemos redefinir ligeiramente a solução. Em vez de considerar só o tempo de chegada, consideramos a diferença do tempo de chegada a vários pontos. Se soubermos 3 tempos de chegada a 3 receptores conhecidos de uma onda emitida no sujeito, calculando a diferença entre estes tempos, podemos deduzir três hiperbolóides. Seguindo um pensamento similar ao da trilateração\footnote{ Cada diferença de tempo de chegada da onda num par de receptores pode definir uma hiperbolóide. Se mantivermos o pensamento da trilateração mas substituirmos os círculos por estas hiperbolóides, temos a localização do sujeito.}, temos a posição do sujeito. Esta implementação é apelidada Multilateração, ou localização hiperbolóide [WP:Multilateration].

O maior obstáculo em ambos os métodos é o da medição de tempos. Os níveis de precisão e exactidão do método são directamente proporcionais aos existentes na medição dos tempos. 

\subsubsection{Alterações no voo}


A atenuação da potência da onda é quadrática ao longo do trajecto, segundo a equação de radar [WP:Radar]. Se um receptor souber a potência de sinal da onda à saída do sujeito e a potência com que a recebe, podemos calcular a distância com a equação de radar (ou uma variação mais apropriada da mesma).

Aqui, o problema é saber as duas potências. Geralmente, os receptores têm uma indicação da força de sinal recebida (conhecida por RSSI, acrónimo do inglês \emph{Recieved Signal Strength Indication}). A potência emitida tem de ser dada a conhecer ao receptor de alguma maneira.

\subsubsection{Problema comum: Reflexões}


Uma onda omnidireccional pode ser vista como uma série de ondas direccionais em todos os sentidos. Se uma destas ondas for reflectida, o receptor pode ver duas vezes a mesma onda, a directa e a reflectida. A reflexão pode ser feita por vários tipos de obstáculos: objectos metálicos, montanhas, etc.{\ldots} Além disso, a onda directa pode nunca chegar ao receptor, chegando só reflexões. [WP:Multipath]





























\fbox{
\begin{minipage}{400.55pt}
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a binary object named ``Multichemin''}}
\end{minipage}
}

Nos cálculos de ângulo de voo, podemos ver várias \emph{imagens} do mesmo objecto, o que pode dificultar a decisão sobre o ângulo.

Tanto no tempo como nas alterações de voo, acabamos por ver várias recepções da mesma onda. Se não ignorarmos as reflexões, que chegam mais tarde que a onda directa, podemos pensar que, por momentos, o objecto se distanciou.

Há algumas maneiras de contrariar os efeitos das reflexões. Por exemplo, as descritas em [WP:Orthogonal\_frequency\_division\_modulation] ou [WP:Rake\_receiver].

\subsection{Bluetooth}


\subsubsection{Introdução}


\emph{Bluetooth}, também conhecido por BT, é uma especificação industrial para redes pessoais sem fios. O BT permite conectar e trocar informação entre dispositivos tais como telefones, portáteis, computadores, impressoras, câmaras digitais e consolas de vídeo jogos, sobre ondas rádio de forma segura. A especificação de BT é desenvolvida e licenciada pelo \emph{Bluetooth Special Interest Group}.

O BT define o protocolo de comunicações e o standard de comunicação rádio. Foi desenhado com o objectivo de ter baixos consumos, apoiando-se em emissores/receptores de custo reduzido. Os alcances variam conforme a classe do dispositivo BT (Classe 3: \~1 metro; Classe 2: \~10 metros; Classe 1: \~100 metros).

O BT permite que estes dispositivos comuniquem entre si quando estiverem ao alcance uns dos outros. Os dispositivos usam um sistema de comunicações por rádio e, por isso, não precisam de estar ao alcance visual entre eles. Podem até estar em divisões diferentes, desde que a transmissão seja suficientemente forte.

O protocolo opera na banda ISM, livre de licenciamento, na banda de frequências 2.4-2.4835 GHz. Para evitar que interfira com outros protocolos que usam esta banda, o BT divide a banda em 79 canais (cada um de 1 MHz) e alterna entre esses canais. [WP:Bluetooth]

\subsubsection{Arquitectura típica}


Tomemos como exemplo da arquitectura da implementação de BT da Microsoft, descrita no diagrama da figura X (retirado de [MS:BluetoothStackArchitecture]).

Exceptuando os módulos de TDI e WinSock, todas as outras implementações seguem a mesma linha de pensamento.













\fbox{
\begin{minipage}{125.9pt}
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a binary object named ``ms863323''}}
\end{minipage}
}\includegraphics[width=198.75pt,height=283.5pt]{}

De um modo muito grosseiro podemos dividir a arquitectura em 3 grande partes: O \emph{hardware} de BT, o HCI e os serviços de BT.

\paragraph{Hardware Bluetooth}


O \emph{hardware} de BT é responsável por implementar as três partes de mais baixo nível de todo do sistema. Estas são a interface com o emissor/receptor de ondas rádio, o controlador de canais rádio e uma interface HCI.

A interface com o emissor/receptor de ondas rádio é responsável pela manipulação e detecção de ondas rádio.

O controlador de canais é responsável pela gestão dos canais de rádio. Isto passa por atender as ordens de manipulações dos canais (estabelecer um canal, enviar dados por um determinado canal, etc.). É também responsável por sinalizar as alterações feitas nos canais (um canal fechou inesperadamente, há dados à espera de serem lidos num certo canal, etc.).

\paragraph{HCI}


HCI é o acrónimo de \emph{Host}\emph{ -- Controller}\emph{ Interface}, inglês de Interface Controlador -- Anfitrião. Como o nome indica, o HCI é a interface que define o protocolo de comunicação entre o controlador de BT e o anfitrião onde este está alojado. Tanto o \emph{hardware} de BT como o sistema operativo anfitrião têm uma implementação do HCI e é através desta interface que comunicam. 

Tendo em conta que toda a comunicação de dados é feita pelo HCI, este é o denominador comum de toda a funcionalidade.

\paragraph{Serviços de Bluetooth}


Os serviços de BT estão implementados do lado do anfitrião. Todos os serviços se apoiam, directa ou indirectamente, no HCI. Há uma grande panóplia de serviços \emph{standard} disponíveis, mas não são relevantes para a resolução do problema. Qualquer tipo de informação sobre as ondas rádios terá que ser disponibilizada pelo HCI. Logo, podemos ignorar todos estes serviços e focarmo-nos na manipulação e inspecção do \emph{hardware} de BT através do HCI.

\section{Radiolocalização em Bluetooth}
\label{_Ref177229713}

Sabendo as condições que o BT oferece, passaremos à análise da exequibilidade de cada método de radiolocalização.



\subsubsection{Ângulo de recepção}


Os modelos comuns são todos comercializados com antenas omnidireccionais. Uma solução que adoptasse esta técnica teria de usar \emph{hardware} específico.

\subsubsection{Tempo de voo}


O HCI não fornece precisão suficiente sobre a altura em que as ondas foram recebidas.

Isto poderia ser feito indirectamente com recurso a restrições de QoS\emph{, }(acrónimo de\emph{ }\emph{Quality of Service}, inglês para Qualidade de Serviço\emph{)}\emph{.} Uma ligação pode ter termos mínimos de qualidade associados. Se estes forem violados, o HCI deveria notificar os intervenientes na ligação. Se pudéssemos limitar a latência da comunicação, de certa forma estaríamos a controlar o tempo de voo da onda. No entanto, a implementação de BT em alguns dispositivos \emph{Windows Mobile} só suporta intervalos múltiplos de 2,5 segundos. Os valores permitidos não têm uma resolução aceitável para localização dentro de uma sala (em 2,5 segundos, uma onda electromagnética percorre 750 mil quilómetros no vazio).

\subsubsection{Alterações no voo}


O HCI tem três parâmetros que poderiam ser usados como base desta técnica: \emph{Transmit Power}, \emph{Link Quality} e RSSI.

O \emph{Transmit power} é o ganho que está presente na antena de emissão de ondas. Isto poderia ser interpretado como a quantidade de atenuação que uma onda está a sofrer. Se é preciso enviar a onda com mais potência, então está a haver mais atenuação.

O \emph{Link Q}\emph{uality} é um campo que deveria representar a qualidade da ligação. Na especificação, não é feita nenhuma exigência sobre em que características da ligação este valor se deve basear. Na CSR, a \emph{Link Q}\emph{uality} é medida com base no BER, (\emph{Bit }\emph{Error}\emph{ Rate}, inglês para Quociente de Erros por Bit)\emph{, }inglês para taxa de erros em bits. Se pensarmos que uma ligação mais ``frágil'' (que sofre de mais atenuação) tem mais erros por bit, há a possibilidade de existir uma correlação com a atenuação e, por extensão, com a distância.

O RSSI, tal como vem descrito na especificação de BT, é-nos inútil. Quando a potência de sinal recebida está dentro dos parâmetros definidos na especificação BT, o parâmetro está a zero. O valor sobe à medida que recebemos sinal com demasiada potência, e desce à medida que recebemos sinal com potência a menos. No entanto, os emissores são obrigados a manter o RSSI o mais perto do zero que conseguirem. Isto leva a que, se o RSSI desce, ambos os intervenientes subam a potência a que as ondas são trocadas para tentar levar de novo o RSSI a zero. Logo, esta medida vai passar a maior parte do tempo a zero.

Há um comando proprietário da CSR chamado RSSI\_ACL que dá, de facto, uma indicação da força do sinal recebido de uma ligação. Quanto maior a potência recebida, menor é a atenuação. Quanto menor é a atenuação, menor é a distância.

\subsubsection{Tratamento de reflexões}


O HCI nunca fornece mecanismo nem de controlo nem de inspecção directa sobre as características das ondas recebidas. Logo, todo o tratamento a reflexões que houver será feito pelo controlador de rádio do BT, ao qual não há acesso programático.


\part{Estado da Arte e Trabalho relacionado}
\label{_Ref177384090}

Neste capítulo é dado a conhecer o estado da arte, a maneira como outros tentaram resolver este mesmo problema e quais os resultados a que chegaram. De todos os artigos relevantes, são destacados aqueles que documentam métodos e/ou aferições de forma concreta.

Há alguma documentação sobre tentativas de resolução do problema em questão. Maior parte dela descreve o sucesso de um método usado, mas não descreve o método em si. No entanto, há quatro artigos que se destacam por não obedecerem a essa corrente.

Em [BluetoothTri] tentaram usar trilateração simples apoiando-se no RSSI de BT e falharam. Adaptaram uma solução que passou por usar hardware específico. Em [udana-rawcon-04] discute-se como usar o RSSI mas recorrendo a hardware exótico. Ambos estes casos são interessantes porque acabam por concluir que, sem recurso a \emph{hardware} específico, não conseguem deduzir posições apoiando-se no RSSI.

Em [Indoor\_location\_Systems] fala-se sobre um produto comercial. No artigo analisam-se os vários métodos de localização e várias escolhas tecnológicas, entre estas BT. BT acaba por sobressair, sobretudo pela forte presença em dispositivos pessoais. A solução adoptada foi um misto de infravermelhos com BT. São apresentados os resultados conseguidos com o produto mas não são explicados os detalhes de implementação, pelo que não se consegue deduzir a ``mecânica'' da solução. Ainda assim, este artigo apresenta um bom comparativo de técnicas e tecnologias.

Em [2005-ubicomp-bluetooth] é documentada uma tentativa de construir um sistema de localização baseado na análise do BER. É usado o sistema \emph{Active }\emph{Bat} [WP:ActiveBat] para recolher a posição real. Concluíram que, embora haja alguma relação entre o BER e a distância, não é suficiente para medir a distância.

Ainda de destacar, há algumas informações sobre um grupo de trabalho sob a alçada da \emph{Bluetooth Special Interest Group} para desenvolver um sistema de posicionamento local [WP:BluetoothSpecialInterestGroup]. No entanto, não se conseguiu encontrar nenhuma informação sobre o trabalho desenvolvido por este grupo.

Com as restrições do problema a ser resolvido, tendo em conta que a pesquisa levada a cabo só encontrou estes quatro artigos relevantes, pode-se dizer com bastante ``à vontade'' que ainda não é conhecida nenhuma solução provada e bem documentada.

\section{Áreas circundantes: WiFi }


Na variação WiFi do problema, há algum trabalho já estabelecido. Mesmo em artigos sobre localização com BT, é muito referido um trabalho da Microsoft: o RADAR [MS:RADAR].

O RADAR é um sistema de radiolocalização para sistemas de ambientes reactivos\footnote{ Um sistema de ambiente reactivo é aquele que tem informação sobre o meio e age com base nela. Por exemplo, um telemóvel entrar em modo de silêncio cada vez que entra numa sala de reuniões. [WP:ContextAwareness]}. Usa WiFi como tecnologia de base. O principal intuito é descobrir a posição do sujeito para descobrir que recursos IP se encontram perto deste. Por exemplo, descobrir que impressora IP se encontra mais perto do sujeito. Há uma demonstração em [MS:RADARDemo].

Tendo em conta que WiFi é uma tecnologia muito presente em dispositivos \emph{Windows Mobile} (o principal alvo a atingir), se redefinirmos o problema, substituindo o uso de BT por WiFi, o sistema RADAR é uma prova concreta de exequibilidade.

O maior problema em usar WiFi é o elevado consumo de bateria. Com a cada vez maior banalização do uso de periféricos BT (principalmente auriculares), é muito comum que os utilizadores tenham o BT ligado a maior parte do tempo. Se a solução desenvolvida apenas precisar que o utilizador tenha o BT ligado, é possível capitalizar este crescendo de dispositivos BT ligados.

\part{Interlúdio: Investigação e Confirmação}
\label{_Ref177463419}

Neste capítulo, será apresentada a investigação levada a cabo para testar as várias hipóteses apresentadas até agora. São explicadas as premissas iniciais e os processos e deduções que levaram até à hipótese final.

\section{Escolha da medida usada}


Tendo em conta a análise feita na secção \ref{_Ref177229713}, por exclusão de hipóteses, podemos dizer que a solução terá que se apoiar no \emph{Transmit Power}, ou no \emph{Link Quality} ou no RSSI\_ACL. Outra hipótese seria o RSSI, caso encontrássemos equipamentos onde este não estivesse bem implementado. Na última das hipóteses, temos extensões proprietárias ao HCI.

O pensamento adoptado foi estritamente pessimista. Tentou-se provar, em primeiro lugar, que nenhuma das hipóteses funcionava. Se a prova falhasse, então é porque existiria uma hipótese que poderia funcionaria. Para ser considerada válida, uma hipótese de relação entre uma medida e a distância teria de o ser de forma bastante óbvia e/ou forte. As condições de teste são, em princípio, melhores\footnote{ Durante a aplicação prática da solução, as condições não serão controladas de todo. Poderão haver outros equipamentos que introduzam interferências no sinal, o movimento de muitas pessoas pode condicionar as transmissões de sinais, etc{\ldots}} do que as condições de uma aplicação prática da solução. Logo, se a relação não for óbvia/forte, tenderá a desaparecer à medida que as condições pioram.

\subsection{Testes das medidas}


Para tentar negar as hipóteses, recolheu-se amostras destas 4 medidas ao longo de várias distâncias. O objectivo era simular um ambiente em que houvesse apenas um Beacon e um Rover e observar o comportamento das medidas. Foram usados dispositivos de classe 1 (alcance de 100 metros) de dois fabricantes diferentes como Beacon, da \emph{Broadcom }e da \emph{Cambridge Silicon }\emph{Rádio} (também conhecida pelo seu acrónimo, CSR). Como Rover, tínhamos vários dispositivos \emph{Windows Mobile} diferentes, todos fabricados pela \emph{HTC}.

\subsubsection{Método}


O sistema de software de apoio era constituído por duas componentes, uma no Beacon e outra no Rover. No Beacon, tínhamos uma aplicação que tinha uma porta de L2CAP à espera de ligações. Quando alguém se ligasse a essa porta, a aplicação enviava as medições pela ligação, para gerar tráfego, e também guardava as medições num ficheiro. No Rover, tínhamos uma aplicação que listava os dispositivos BT visíveis. Depois de se ligar ao Beacon, sempre que o utilizador o pedia, ligava-se à porta de L2CAP aberta no Beacon e apresentava a informação que lhe chegava nessa porta. Ao fim de um minuto, o Rover terminava a ligação. Isto fazia com que, cada vez que o utilizador pedia, se tirasse uma amostra de um minuto das medidas escolhidas.

Com este sistema, tendo o Beacon numa posição, tirávamos amostras de posições consecutivamente mais distantes, ao longo de 50 metros. Com toda a informação das amostras, poderíamos inspeccionar o comportamento das medidas ao longo da distância ao Beacon.

\subsubsection{Resultados}


De seguida, são apresentados os resultados das amostras retiradas. Estes mantêm-se bastante iguais, independentemente do dispositivo usado como Rover, pelo que será apresentado o resultado das amostras retiradas com um PDA \emph{HTC TyTN}. Os gráficos têm no eixo do \emph{x} a distância entre o Rover e o Beacon e no do \emph{y} o valor das medições. Neste, é apresentada uma barra com um ponto. O ponto significa a média e a barra simboliza a média somada e subtraída do desvio padrão.

\paragraph{CSR}


Conforme se pode facilmente observar nas figuras X, Y e Z, nenhuma destas medidas do dispositivo com o \emph{chipset} da CSR está correlacionada com a distância.



Na figura X, o RSSI\_ACL demonstra claramente uma relação logarítmica com a distância e a variação em cada distância não é muito considerável. Com base nestas características, embora não seja possível fazer um relacionamento de causa-efeito, esta medida parece ser um bom indicador da distância entre os dispositivos.



\paragraph{Broadcom}


No \emph{chipset} da \emph{Broadcom}, o RSSI (figura X) aparenta ter alguma relação com a distância. No entanto, esta medida tem um comportamento, no mínimo, irregular e difícil de prever. Tendo em conta a irregularidade desta medida e que não foi encontrada documentação sobre o comportamento da mesma\footnote{ Ainda se entrou em contacto com a Broadcom, mas estes disseram que não estavam interessados em cooperar.}, foi abandonada a hipótese de a usar. 



A medida \emph{Link Quality} (figura X) também evidencia alguma relação com a distância. No entanto a variação das medições tende a ser mínima. Contudo, para distâncias diferentes temos valores iguais com variações mínimas, o que impossibilita a distinção entre estas duas distância. Logo, como por vezes não se consegue distinguir duas distâncias distintas, considerou-se a medida inapta.



A medida Transmit power apresenta uma reduzidíssima relação com a distância, evidenciado apenas se o Rover está a menos de 4 metros.

\subsubsection{Avaliação}


No fim, a única medida que demonstrou resultados que ``inspirassem'' segurança foi a RSSI\_ACL. Esta medida, embora apresente um andamento logarítmico similar em todas as condições sob a forma de 
\[
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a MS Equation Editor Object}}
\], o coeficiente 
\[
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a MS Equation Editor Object}}
\] muda consideravelmente conforme as condições atmosféricas. Logo, o comportamento desta medida não é adequado para simplesmente aplicar a função inversa do comportamento observado. Para ultrapassar isto, ao invés de nos apoiarmos na medição de uma ligação Rover -- Beacon, apoiámo-nos na relação entre as medições de várias ligações.

\section{Relacionamento entre o RSSI\_ACL e distância}
\label{_Ref177300006}

A ideia essencial é um Beacon deduzir o significado do RSSI\_ACL de um Rover, baseando-se no conhecimento das posições dos outros Beacons e no RSSI\_ACL com que ele os ``vê''. A cada outro Beacon que um Beacon mede o RSSI\_ACL, ganha informação sobre qual é a força de sinal com que ``vê'' um dispositivo a uma distância equivalente à que eles estão separados. A relação entre a distância e o RSSI\_ACL a que os Beacons se ``vêem'' é chamada ``régua''\footnote{ O termo ``régua'' foi adoptado apenas no contexto do trabalho desenvolvido no estágio.}. Uma ``régua'' é usada para fazer corresponder uma distância a uma força de sinal. Se tivermos pelo menos uma ``régua'' e o RSSI\_ACL de um Rover, podemos deduzir, com alguma precisão, a distância a que um Rover está de um Beacon. Quanto mais réguas, maior a confiança nas estimativas. Por uma questão de simplicidade, o processo de dedução é uma regra de três simples. Há que ter em conta que isto faz com que seja ignorada a natureza logarítmica da relação, o que poderá levar a erros. A estimativa da posição do Rover é um anel\footnote{ Esta estimativa em forma de anel é, por vezes, referida como donut.}, centrado no Beacon que efectuou a medição, com o raio interior e exterior correspondentes à menor e maior distância calculadas, respectivamente, com recurso às réguas. Isto requer que seja modificado o conceito de trilateração. Em vez de se intersectarem círculos, intersectam-se anéis. Isto faz com que o resultado final seja uma área onde se espera que o Rover esteja localizado.

\subsection{Regras base e testes}


Empiricamente, para que a dedução da distância a partir das ``réguas'' funcione, têm que ser cumpridas duas regras base: dois Beacons devem ``ver-se'' com, sensivelmente, o mesmo RSSI\_ACL; cada Beacon tem de ``ver'' o Rover com o mesmo RSSI\_ACL para a mesma distância.

Para testar a primeira regra, foram dispostos dois Beacon distanciados de meio metro\footnote{ O estagiário já tinha fortes suspeitas que a primeira regra se verificava a todas as distâncias. Por isso, não houve grande preocupação com a distância escolhida.}. Com esta disposição, foram retiras amostras de RSSI\_ACL do Beacon 1 ao Beacon 2, e vice-versa. O Beacon 1 ``viu'' o Beacon 2 com um valor médio de -45 (desvio padrão de 1,9). O Beacon 2 ``viu'' o Beacon 1 com valor médio de -45 (desvio padrão de 2,5). Considerou-se que os valores obtidos seguem o estipulado na primeira regra.

Para testar se a segunda regra se verificava, foi retirada uma segunda amostra. Foram dispostos dois Beacons, sem obstáculos entre eles, a uma distância de 6 metros\footnote{ A escolha deste valor foi claramente conformista. É quanto mede, aproximadamente, um dos lados da sala onde o estagiário trabalhou. Tendo em conta que o tamanho da sala é perfeitamente comum, pareceu uma medida representativa da média.}. Ao longo dos 6 metros, estavam 3 marcas equidistantes. Retiraram-se medições do RSSI\_ACL junto a cada Beacon e a cada marca, cada ligação durando cerca de um minuto. Por norma, à medida que o Rover se distanciava de um Beacon, a média da medida diminuía com o mesmo andamento, independentemente do Beacon em questão. À mesma distância, ambos os Beacons viam o Rover com aproximadamente a mesma média de valor de RSSI\_ACL. A medição a metro e meio do Beacon 2 é aquela que mais contraria o andamento esperado. Em contrapartida, esta medição, ao contrário das outras, teve um desvio padrão de valor 2 onde um valor de 1 seria o normal.
\begin{tabular}{p{3.38cm}p{1.84cm}p{1.74cm}}
\begin{minipage}{3.38cm}
\begin{flushleft}


\end{minipage} & 
\begin{minipage}{1.84cm}
\begin{center}
{{\scriptsize RSSI\_ACL}}
\end{center}
\end{minipage} \\
\begin{minipage}{3.38cm}
\begin{flushleft}
{{\scriptsize Distância ao Rover}}

\end{minipage} & 
\begin{minipage}{1.84cm}
\begin{flushleft}
{{\scriptsize Beacon 1}}

\end{minipage} & 
\begin{minipage}{1.74cm}
\begin{flushleft}
{{\scriptsize Beacon 2}}

\end{minipage} \\
\begin{minipage}{3.38cm}
\begin{flushright}
{{\scriptsize 0}}
\end{flushright}
\end{minipage} & 
\begin{minipage}{1.84cm}
\begin{flushright}
{{\scriptsize -27}}
\end{flushright}
\end{minipage} & 
\begin{minipage}{1.74cm}
\begin{flushright}
{{\scriptsize -32}}
\end{flushright}
\end{minipage} \\
\begin{minipage}{3.38cm}
\begin{flushright}
{{\scriptsize 1,5}}
\end{flushright}
\end{minipage} & 
\begin{minipage}{1.84cm}
\begin{flushright}
{{\scriptsize -40}}
\end{flushright}
\end{minipage} & 
\begin{minipage}{1.74cm}
\begin{flushright}
{{\scriptsize -49}}
\end{flushright}
\end{minipage} \\
\begin{minipage}{3.38cm}
\begin{flushright}
{{\scriptsize 3}}
\end{flushright}
\end{minipage} & 
\begin{minipage}{1.84cm}
\begin{flushright}
{{\scriptsize -48}}
\end{flushright}
\end{minipage} & 
\begin{minipage}{1.74cm}
\begin{flushright}
{{\scriptsize -47}}
\end{flushright}
\end{minipage} \\
\begin{minipage}{3.38cm}
\begin{flushright}
{{\scriptsize 4,5}}
\end{flushright}
\end{minipage} & 
\begin{minipage}{1.84cm}
\begin{flushright}
{{\scriptsize -53}}
\end{flushright}
\end{minipage} & 
\begin{minipage}{1.74cm}
\begin{flushright}
{{\scriptsize -51}}
\end{flushright}
\end{minipage} \\
\begin{minipage}{3.38cm}
\begin{flushright}
{{\scriptsize 6}}
\end{flushright}
\end{minipage} & 
\begin{minipage}{1.84cm}
\begin{flushright}
{{\scriptsize -56}}
\end{flushright}
\end{minipage} & 
\begin{minipage}{1.74cm}
\begin{flushright}
{{\scriptsize -59}}
\end{flushright}
\end{minipage} \\
\end{tabular}

\fbox{
\begin{minipage}{453.45pt}
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a binary object named ``''}}
\end{minipage}
}

Como as amostras não violaram demasiado as regras dispostas, esta foi a base do trabalho desenvolvido.

\part{Solução}
\label{_Ref177464089}

Neste capítulo será exposta a arquitectura da solução na sua totalidade. A análise é dividida na sua componente física e lógica.

\section{Arquitectura Física}
\label{_Ref177755736}

Um Beacon é composto pelo dispositivo BT e por uma máquina que o hospeda. Além dos Beacons, existe uma máquina central. Todos os Beacons estão ligados de alguma maneira à máquina central, tipicamente através duma rede \emph{Ethernet}. Os Rovers, os dispositivos BT a localizar, podem estar presentes, ou não.

O principal requisito para executar radiolocalização passiva é ter Beacons nas posições devidas\footnote{ A escolha das posições dos Beacons é exemplificada na secção 7.1.1}. Os Beacons devem estar dispostos tal forma que, todas as posições que nos interessa monitorar a presença do Rover, estejam ao alcance de pelo menos três Beacons (para ter as informações mínimas para a trilateração).

O objectivo é que os Beacons testem a presença dos Rovers, e quando conseguem estabelecer uma ligação com um Rover, meçam o RSSI\_ACL da ligação e enviem a medição a um computador central, chamado Central. Este é responsável por tentar deduzir a localização \includegraphics[width=117pt,height=9pt;z-index:6;mso-position-horizontal-relative:text;mso-position-vertical-relative:line]{}de todos os Rovers a que os Beacons consigam tirar medidas.

\fbox{
\begin{minipage}{230.4pt}
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a binary object named ``arq fisica''}}
\end{minipage}
}

\section{Arquitectura Lógica}


A arquitectura lógica é dividida em duas grandes partes: o Beacon e o Central.

\fbox{
\begin{minipage}{452.55pt}
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a binary object named ``ArqLogica''}}
\end{minipage}
}

\subsection{Beacon}


O Beacon divide-se em três pacotes: o Address Manager, o Probe e o Beacon Probe.

\subsubsection{Address Manager}


O Address Manager é responsável pela comunicação com o Central. Isto passa por:
\begin{itemize}
\item Avisar o Central do início e do fim de uma sessão de funcionamento do Beacon,
\item Receber os pedidos de monitorização de Rovers e Beacons enviados pelo Central e criar um Probe ou Beacon Probe, respectivamente, para cada um dos monitorizados,
\item Avisar o Central do início e fim de ligação com um Rover ou Beacon,
\item Enviar as medições de RSSI\_ACL recolhidas pelos Probes.
\end{itemize}
\end{enumerate}

A comunicação com o Central é feita através de sockets, trocando informação codificada em texto simples, conforme o protocolo definido (Ver secção \ref{_Ref177154266}).

\subsubsection{Probe}


Um Probe é responsável por monitorizar a presença de um Rover em específico, que lhe é dado a conhecer na criação. Isto passa por:
\begin{itemize}
\item Tentar-se ligar ao Rover e avisar o Address Manager quando conseguir.
\item Enquanto estiver ligado, medir o RSSI\_ACL da ligação.
\item No fim da ligação, informar o Address Manager.
\end{itemize}
\end{enumerate}

Quando a ligação se perder, o Probe volta a tentar ligar-se ao Rover.

\subsubsection{Beacon Probe}


O Beacon Probe é apenas um Probe que tem com objectivo monitorizar um Beacon ao invés de um Rover. Deverão ser feitas as modificações necessárias para tomar partido da menor volatilidade da presença de Beacons.

\subsection{Central}


O Central divide-se em quatro pacotes: o Business Entities, o Dispatcher, o Localizer, e o Visualizer.

\subsubsection{Business Entities}


As Business Entities são apenas classes que representam as entidades e conceitos envolvidos no processo de localização. Estas classes foram colocadas num pacote à parte porque são as únicas classes a persistir em base de dados. Algumas destas classes contêm um campo chamado Id. Este apenas é usado como chave primária na base de dados. Segue-se a descrição de cada classe. 

\paragraph{Bluetooth Address}


Representa um endereço BT. Um endereço BT é constituído por 6 bytes.

\paragraph{Device}


Classe abstracta que representa um dispositivo BT. Contém um Bluetooth Address e informações genéricas das propriedades do \emph{chipset} do dispositivo. A propriedade Is A Beacon é abstracta e deverá devolver verdadeiro caso o objecto represente um Beacon.

\paragraph{Rover}


Descendente de Device, representa um Rover. A propriedade Registry Date contém a data em que o dispositivo foi registado. A colecção Links contém todas as ligações em que o Rover participou.

\paragraph{Beacon}


Descendente de Device, representa um Beacon. Contém uma Position que representa a posição do Beacon. As propriedades X e Y são apenas chamadas às mesmas no objecto Position contido. A colecção Sessions contém todas as sessões de funcionamento do Beacon.

\paragraph{Position}


Representa uma posição num sistema de dois eixos. As propriedades X e Y são os valores no primeiro e segundo eixo, respectivamente.

\paragraph{Session}


Representa uma sessão de funcionamento de um Beacon. Contém o Beacon a que a sessão se refere, o conjunto das ligações que esse Beacon efectuou (representado pela colecção Links), e as datas e horas de início e fim.

\paragraph{Link}


Representa uma ligação de um Beacon a um dispositivo BT. Contém as datas e horas de início e fim da ligação, a sessão sob a qual foi estabelecida, o dispositivo a que foi feita a ligação, e o conjunto de leituras efectuadas na ligação (representado pela colecção Readings).

\paragraph{Reading}


Classe abstracta que representa uma medição genérica. Contém a ligação, data e hora em que foi retirada. Esta classe deve ser estendida para cada medida usada.

\paragraph{RssiAcl}


Descendente de Reading, representa uma medição de RSSI\_ACL. Contém o valor da medição.

\subsubsection{Dispatcher}


O pacote Dispatcher é responsável pela comunicação com o Beacon, comunicar com a base de dados, e avisar os interessados das leituras feitas pelos Beacons.

A comunicação com o Beacon é feita através de sockets, trocando informação codificada em texto simples, conforme o protocolo definido (Ver secção \ref{_Ref177154266}). Para interpretar e validar a sequência das mensagens recebidas, usa-se uma máquina de estados, implementada na classe Protocol Talker\footnote{ A descrição do funcionamento do Protocol Talker está na secção 5.3.}. Cada instância de Protocol Talker contém um Repository e, com recurso aos métodos deste, manipula objectos do pacote Business Entities para representar a informação que recebe dos Beacons. O Repository é responsável pela persistência da informação em base de dados e proporciona três eventos para que interessados em novas informações possam ser notificados. Os eventos são o início e fim de ligações e as medições efectuadas\footnote{ O evento de medição efectuada, para ser correcto, deveria conter um objecto Reading. Por uma questão de simplicidade de implementação, sabendo que todas as medições serão de RSSI\_ACL, é passado directamente o valor da medição ao invés do objecto.}. A persistência em base de dados é feita com recurso à \emph{framework} \emph{NHibernate}. A informação persistida é constituída por instâncias das classes do pacote Business Entities.

\subsubsection{Localizer}


O Localizer é responsável por tentar deduzir as posições dos Rovers.

A classe central deste pacote é a DonutLocalizer. Esta classe subscreve os eventos lançados pelo Repository e manipula os objectos das classes deste pacote para representar o estado do mundo. Contém objectos Ruler e Donut, que são as bases das estimativas efectuadas.

A classe Ruler simboliza uma ``régua''\footnote{ O conceito de ``régua'' foi explicado na secção 4.2.}. Contém os Beacons de origem e destino da ``régua'' e as medições de RSSI\_ACL efectuadas nessa ligação.

A classe Donut representa o anel da estimativa da posição de um Rover em relação a um Beacon. Contém o Beacon que efectuou a estimativa (que é o centro do anel), o PositionedRover a que a estimativa se aplica, a área da estimativa e as medições de RSSI\_ACL que apoiam a dedução do anel.

A classe PositionedRover represente o mesmo que a classe Rover acrescida da estimativa actual da posição do Rover que representa. A estimativa é representada na área onde se espera que o Rover esteja e a posição do centro geométrico dessa área. Esta área é a intersecção de todos os anéis calculados pelos Beacons.

As áreas são representadas por objectos da classe BinaryMap. O funcionamento desta classe é explicado na secção \ref{_Ref177195931}.

\subsubsection{Visualizer}


\fbox{
\begin{minipage}{163.9pt}
\textsl{\textcolor{red}{Sorry, WordML2LaTeX couldn't translate a binary object named ``ClassDiagram1''}}
\end{minipage}
}O pacote Visualizer é responsável por mostrar ao utilizador a informação deduzida pelo Localizer.

A classe MapPanel é um painel responsável por desenhar no ecrã as posições deduzidas. Para isto, pede à classe Localizer todos os objectos PositionedRover e Beacon, transforma-os em PaintablePositionedRover e PaintableBeacon (respectivamente), e delega o desenho dos objectos aos mesmos.

A classe PaintablePositionedRover e PaintableBeacon, derivadas de PositionedRover e Beacon (respectivamente), adicionam apenas a capacidade do objecto se desenhar.

\section{Protocolo de comunicação Beacon -- Central}
\label{_Ref177154266}

O protocolo de comunicação Beacon -- Central tem dois grandes propósitos, informar o Central das medidas efectuadas pelos Beacons e informar os Beacon quais os dispositivos a procurar. As mensagens trocadas são em texto simples.

\subsection{Sinalização do início e fim de sessão}


O Beacon informa o Central quando começa ou acaba a sessão de funcionamento.

Uma mensagem de início de funcionamento tem a forma de:
\begin{center}
{\scriptsize 11806347792159490 00:14:85:96:8B:12 HELLO}
\end{center}

Uma mensagem de fim de funcionamento tem a forma de:
\begin{center}
{\scriptsize 11806351052549630 00:14:85:96:8B:11 BYE}
\end{center}
\begin{flushleft}
``{11806347792159490}'' é o \emph{timestamp}\emph{\footnote{ Estes timestamps tomam a mesma forma que a propriedade Ticks da classe DateTime de .NET.}} em que a mensagem foi enviada.


``{00:14:85:96:8B:12}'' é o endereço BT do Beacon.

\subsection{Sinalização dos dispositivos a procurar}


Quando um Beacon inicia uma sessão, o Central informa-o dos dispositivos que deve procurar. Isto é feito enviando várias mensagens de endereço, uma para cada dispositivo a ser procurado.

Uma mensagem de endereço de um Rover a procurar tem a forma de:
\begin{center}
11806095134787740 ROVER  {\scriptsize 00:12:D1:CB:A9:5A}
\end{center}

Uma mensagem de endereço de um Beacon a procurar tem a forma de:
\begin{center}
11806095141957640 BEACON {\scriptsize 00:14:85:96:8B:12}
\end{center}

``{11806347792159490}'' é o \emph{timestamp} em que a mensagem foi enviada. 

``{BEACON'' ou ``ROVER}'' indica se o endereço se trata de um Beacon ou um Rover, respectivamente.

``{00:14:85:96:8B:12}'' é o endereço do dispositivo que deve ser procurado.

\subsection{Sinalização de ligações e medições}


O Beacon informa o Central quando é iniciada ou terminada uma ligação com outro dispositivo e quando são efectuada medidas numa ligação.



Uma mensagem de início de ligação tem a forma de:
\begin{center}
{\scriptsize 11806347941973370 00:14:85:96:8B:12 00:12:D1:CB:A9:5A NEW LINK}
\end{center}

Uma mensagem de fim de ligação tem a forma de:
\begin{center}
{\scriptsize 11806348112761370}{\scriptsize  }{\scriptsize 00:14:85:96:8B:12 00:12:D1:CB:A9:5A END LINK}
\end{center}

Uma mensagem de medição tem a forma de:
\begin{center}
{\scriptsize 11806348103457710 00:14:85:96:8B:12 00:12:D1:CB:A9:5A RSSI ACL -26}
\end{center}

``{11806347792159490}'' é o \emph{timestamp} em que a mensagem foi enviada. 

``{00:14:85:96:8B:12}'' é o endereço BT do Beacon. 

``{00:12:D1:CB:A9:5A}'' é o endereço BT do dispositivo do outro lado da ligação.

``{-26}'' é o valor da medida retirada.

\part{Implementação do Protótipo}
\label{_Ref31804414}\label{_Ref177195931}

Neste capítulo serão explicados detalhes da implementação. Nomeadamente, a escolha de tecnologias e dificuldades no uso das mesmas, as partes que não foram implementadas, o funcionamento de certas classes menos convencionais e como alterar o método de localização usado.

\section{Escolha de tecnologias}


\subsection{Beacon}


Antes de sequer testar as medidas como foi feito no capítulo \ref{_Ref177463419}, foi preciso criar um ambiente que permitisse acesso ao HCI.

A primeira tentativa de criar este ambiente foi em \emph{Windows Mobile 4}. Criar um ambiente neste SO era particularmente útil devido à disponibilidade de equipamentos com este SO. No entanto, a biblioteca disponível e respectiva documentação são relativamente complexas. Por isso, não se conseguiu criar o ambiente necessário.

A próxima hipótese era criar o ambiente em \emph{Windows}, tendo em conta a ampla disponibilidade com computadores com este SO. A única maneira de aceder ao HCI é em \emph{Kernel Land}, em \emph{Drivers}. Logo, tendo em conta o investimento considerável que teria que haver para construir um \emph{Driver} específico para esta tarefa, foi abandonada a hipótese.

Embora também haja algumas ferramentas para comunicação com o HCI em \emph{Java}, todas as tentativas, em ambiente \emph{Windows}, falharam.

Em \emph{Linux}, há uma \emph{framework} de BT chamada \emph{BlueZ}. Esta \emph{framework} permite acesso relativamente simples, embora trabalhoso, ao HCI.

Havia ainda a hipótese de usar \emph{OS X}, o SO da \emph{Apple}. Seguir por esta hipótese obrigaria a que o custo de cada Beacon fosse consideravelmente mais elevado, comparado com o uso de \emph{Linux}. Uma pesquisa breve não revelou nenhum resultado relevante, pelo que também se abandonou a hipótese.

No final, a única alternativa era usar BlueZ. Foi nesta \emph{framework} que assentou todo o trabalho na componente do Beacon.

\subsection{Central}


Do lado do Central, a tecnologia usada é toda assente em \emph{.NET}. Havia imensas possibilidades para a implementação deste sistema, tendo em conta que a única restrição era conseguir ler dados de uma rede \emph{E}\emph{hternet}.

A escolha acabou por recair sobre \emph{.NET} porque:
\begin{itemize}
\item Havia um IDE relativamente poderoso (\emph{Visual Studio 2005}) disponível para uso;
\item A tecnologia é madura o suficiente para já existirem muitas bibliotecas testadas e usadas com sucesso; e
\item Acima de tudo, o estagiário tinha ao seu dispor a ajuda de dois colegas muito experientes em \emph{.NET}.
\end{itemize}
\end{enumerate}

A linguagem de programação usada foi C\#, devido à vasta experiência do estagiário em Java, pois Java e C\# são muito parecidos.

A persistência de dados foi conseguida através do uso de \emph{NHibernate}. Esta \emph{framework} permite que, apenas adicionando algumas anotações, o acesso à base de dados seja todo abstraído e automatizado, inclusive a geração do esquema de dados [NHibernate.org].

Para interface com o utilizador no pacote Visualizer, foi usado Windows Forms.

\section{Dificuldades no uso da Framework BlueZ}


Além do processo moroso de disposição física dos dispositivos, um dos aspectos que mais atrasou o desenvolvimento foi a adaptação à \emph{framework} BlueZ. A \emph{framework} esconde e/ou abstrai pormenores do funcionamento do BT para simplificar o pensamento do programador. Esta abstracção nem sempre é benéfica ou, sequer, bem implementada. Um dos casos mais notórios é o dos \emph{timeouts} no estabelecimento das ligações. Como a \emph{framework} não tem documentação além do código em si, todo o esforço inicial passou por compreender como outras pessoas usaram a \emph{framework}.

Todas as chamadas à função de criação de ligações levavam um parâmetro chamado \emph{to}, de \emph{TimeOut}. No entanto, este \emph{timeout} não é o tempo máximo de espera pelo estabelecimento da ligação, mas sim o tempo máximo que o código espera pela confirmação da ligação. Isto levou a casos onde o código falhava o estabelecimento da ligação mas, inquirindo o HCI com as ferramentas certas, a ligação era criada. Só esta confusão atrasou imenso a implementação. Foi fonte de inúmeras confusões até o estagiário se ter apercebido do que é que, ao certo, se estava a passar.

No fim, a ideia que passou foi a de que, para controlo preciso do HCI, é preferível não delegar o tratamento da comunicação, ganhando um maior controlo sobre todos os processos de BT. Para situações em que não é preciso tamanho controlo, o uso da \emph{framework} deverá ser uma vantagem.

\section{Partes não implementadas}


A única parte do sistema, tal como especificado no capítulo \ref{_Ref177464089}, que não foi implementada foi parte da comunicação Central --- Beacon. No protótipo, os dispositivos que o Beacon procurava estavam descritos em código, ao invés de lhe serem comunicados pelo central.

De resto, foi implementada a totalidade da solução

\section{Implementação de classes}


Nesta secção é explicado o funcionamento de duas classes que, embora não suficientemente relevante para estar na descrição da solução, é importante para se perceber o funcionamento do sistema como um todo.

\subsection{Binary Map}


O objectivo desta classe é representar uma figura geométrica presente numa área de duas dimensões através de um \emph{array} bidimensional, como se fosse um quadriculado. A área que contém a figura é mapeada num array bidimensional de booleanos. Se a posição do array correspondente a uma parte da área mapeada contiver o valor ``verdadeiro'', então essa parte da área pertence à figura geométrica representada.

Um objecto desta classe tem os valores mínimos e máximos de cada eixo da área representada, o factor de escala para cada eixo e o array de booleanos.

\subsection{Protocol Talker e  Machine}


O tratamento da comunicação Beacon --- Central é feito com recurso a uma máquina de estados. A máquina de estados em si está implementada na classe abstracta StringStateMachine. O objectivo desta classe é ler dados, \emph{input}, de uma \emph{stream} e chamar métodos conforme o formato desses dados.

Tentando fazer um mapeamento para a definição teórica de máquina de estado temos:
\begin{itemize}
\item Alfabeto de entrada: símbolos ASCII.
\item Conjunto de estados: conjunto de métodos com o atributo State, ou equivalente. Estes métodos têm de obedecer ao \emph{delegate} StringStateMachine.State. Devem devolver o conjunto de estados que serão aceites a seguir ao processamento deste estado. Quando a máquina de estados entra num estado, é executado o método correspondente.
\item Estado inicial: este estado está implícito no construtor.
\item Função de transição de estados: este conceito está um pouco adulterado. Ao invés de receber o estado actual e o \emph{input} e devolver o próximo estado, a função recebe o \emph{input} e um mapa de RegEx para função, que representa as transições possíveis, e devolve o próximo estado. A RegEx correspondente a um estado está na anotação do método que o representa. Os próximos estados possíveis são devolvidos pelo estado anterior. Os estados possíveis para a primeira transição são os marcados com a anotação StartingState (que descende da anotação State).
\item Estados finais: um estado é considerado final quando chama a função End durante a execução.
\end{itemize}
\end{enumerate}

A classe ProtocolTalker, descendente de StringStateMachine, implementa apenas os métodos, anotados devidamente, que devem ser chamados cada vez que chega uma mensagem do Beacon.

\section{Como mudar de método de localização no sistema actual}


Para mudar o método de localização temos de ter atenção a dois aspectos: onde se guardam as medições efectuadas e como são calculadas as estimativas das posições dos Rovers.

As medições efectuadas estão guardadas em duas classes diferentes, conforme a natureza da medição. As medições Beacon---Beacon  estão guardadas em objectos da classe Ruler. As medidas Beacon---Rover estão guardadas em objectos da classe Donut. Em ambos os casos, é mantida uma lista (chamada {{\scriptsize values}) das \emph{N} últimas medições efectuadas, onde \emph{N} é um valor estático de cada classe (chamado {\scriptsize BACKLOG}). O acesso a esta lista, feito através de chamadas ao método {\scriptsize GetRssi}, supõe que apenas queremos um único valor; por exemplo, a média das medições guardadas. Na implementação actual, a lista guarda apenas um valor e o método {\scriptsize GetRssi}} devolve esse valor.

O cálculo das estimativas está, também, distribuído por dois sítios, objectos da classe Donut e da classe PositionedRover. Os objectos Donut são responsáveis por calcular o anel, centrado no Beacon desse Donut, onde estimam que o Rover desse Donut esteja. Na implementação actual, o raio interno e externo do anel é calculado no método GetRadius, e é ai que é feita a relação entre as medições e a distância. Os objectos PositionedRover são responsáveis por intersectar todos os anéis que se referem ao Rover representado pelo objecto.

\subsection{Exemplo das modificações necessárias para um calculo alternativo}


Sabendo que o RSSI\_ACL é logarítmico ao longo da distância, podemos dizer que a distância é exponencial ao longo do RSSI\_ACL. A título de exemplo, suponha-se que é pretendido que a distância seja calculada com recurso a uma regressão exponencial em vez de recorrer ao pensamento explicado em \ref{_Ref177300006}. Para isso, precisaríamos de duas modificações: criar um mecanismo que efectuasse a regressão e adaptar a implementação para o usar.

Primeiro, seria criada uma classe responsável pelo cálculo da regressão. Esta receberia um dicionário, onde as chaves fossem medições e o valor de cada chave fosse a distância a que essa medição foi recolhida, e devolveria uma função que representava o resultado da regressão.

Esqueleto da implementação da função de calculo da regressão em C\# 2.0.
\begin{flushleft}
{\textcolor[rgb]{0,0,1}{{\scriptsize public}}{\scriptsize  }\textcolor[rgb]{0,0,1}{{\scriptsize delegate}}{\scriptsize  }\textcolor[rgb]{0,0,1}{{\scriptsize double}}{\scriptsize  }\textcolor[rgb]{0.16862745098039217,0.5686274509803921,0.6862745098039216}{{\scriptsize Regression}}{\scriptsize  (}\textcolor[rgb]{0,0,1}{{\scriptsize short}}{\scriptsize  x);}}

\begin{flushleft}
{\textcolor[rgb]{0,0,1}{{\scriptsize public}}{\scriptsize  }\textcolor[rgb]{0.16862745098039217,0.5686274509803921,0.6862745098039216}{{\scriptsize Regression}}{\scriptsize  DeduceExpRegression}{\scriptsize (}\textcolor[rgb]{0.16862745098039217,0.5686274509803921,0.6862745098039216}{{\scriptsize Dictionary}}{\scriptsize <}\textcolor[rgb]{0,0,1}{{\scriptsize short}}{\scriptsize , }\textcolor[rgb]{0,0,1}{{\scriptsize double}}{\scriptsize > evidence)}{\scriptsize \{}}

\begin{flushleft}
\hspace{1.2672040550529761cm}{{\scriptsize }\textcolor[rgb]{0,0.5019607843137255,0}{{\scriptsize //we should get something like y = }}\textcolor[rgb]{0,0.5019607843137255,0}{{\scriptsize e$\hat{}$(x-}}\textcolor[rgb]{0,0.5019607843137255,0}{{\scriptsize B}}\textcolor[rgb]{0,0.5019607843137255,0}{{\scriptsize /A) + C}}\textcolor[rgb]{0,0.5019607843137255,0}{{\scriptsize . We want A}}\textcolor[rgb]{0,0.5019607843137255,0}{{\scriptsize , }}\textcolor[rgb]{0,0.5019607843137255,0}{{\scriptsize B}}\textcolor[rgb]{0,0.5019607843137255,0}{{\scriptsize  and C.}}}

\begin{flushleft}
\hspace{1.2672040550529761cm}{{\scriptsize }\textcolor[rgb]{0,0,1}{{\scriptsize double}}{\scriptsize  a = }\textcolor[rgb]{0,0,1}{{\scriptsize this}}{\scriptsize .CalculateA(evidence);}}

\begin{flushleft}
\hspace{1.2672040550529761cm}{{\scriptsize }\textcolor[rgb]{0,0,1}{{\scriptsize double}}{\scriptsize  b = }\textcolor[rgb]{0,0,1}{{\scriptsize this}}{\scriptsize .CalculateB(evidence);}}

\begin{flushleft}
\hspace{1.2672040550529761cm}{{\scriptsize }\textcolor[rgb]{0,0,1}{{\scriptsize double}}{\scriptsize  c}{\scriptsize  = }\textcolor[rgb]{0,0,1}{{\scriptsize this}}{\scriptsize .Calculate}{\scriptsize C}{\scriptsize (evidence);}}

\begin{flushleft}
\hspace{1.2672040550529761cm}{{\scriptsize }\textcolor[rgb]{0,0,1}{{\scriptsize return}}{\scriptsize  }\textcolor[rgb]{0,0,1}{{\scriptsize new}}{\scriptsize  }\textcolor[rgb]{0.16862745098039217,0.5686274509803921,0.6862745098039216}{{\scriptsize RegressionResult}}{\scriptsize (}\textcolor[rgb]{0,0,1}{{\scriptsize delegate}}{\scriptsize (}\textcolor[rgb]{0,0,1}{{\scriptsize short}}{\scriptsize  x) \{}}

\begin{flushleft}
\hspace{1.2672040550529761cm}{{\scriptsize }\hspace{1.2672040550529761cm}{\scriptsize }\textcolor[rgb]{0,0,1}{{\scriptsize return}}{\scriptsize  }\textcolor[rgb]{0.16862745098039217,0.5686274509803921,0.6862745098039216}{{\scriptsize Math}}{\scriptsize .Exp(x - b / a)}{\scriptsize  + c}{\scriptsize ;}}

\begin{flushleft}
\hspace{1.2672040550529761cm}{{\scriptsize }{\scriptsize \});}}


{{\scriptsize \}}}

Em segundo lugar, seria alterado o método GetRadius para:
\begin{enumerate}
\item Passar por todos os objectos Ruler e recolher a distância que cada um representa e a medição ai guardada,
\item Manipular a estrutura dessa informação para estar de acordo com o dicionário que a classe de regressão requer,
\item Dar ao método da classe (ou do objecto da classe, conforme a implementação) o dicionário para efectuar a regressão, e
\item Guardar a função resultante da regressão.
\end{enumerate}
\end{enumerate}

Posto isto, era só chamar o método resultante com o RSSI\_ACL do Donut para ter uma distância.

\part{Resultados, Avaliação e Trabalho Futuro}


Neste capítulo será exposto o funcionamento comum do protótipo desenvolvido, serão avaliados os resultados do mesmo e serão feitas propostas de trabalho futuro.

\section{Funcionamento típico do protótipo desenvolvido}


Nesta secção será retratado o funcionamento típico do protótipo desenvolvido. Começaremos pela instalação das componentes físicas, pelos procedimentos de ``arranque'', passando pelo funcionamento pleno de todo o sistema até ao comportamento das deduções efectuadas.

\subsection{Instalação e Arranque}
\label{_Ref177923737}

O primeiro aspecto a ter em mente é o sítio que cada Beacon terá. Estes devem estar dispostos de modo a que todas as posições a monitorizar estejam cobertas pelo alcance de, pelo menos, três Beacons.

Inserir figura de mau posicionamento

Inserir figura de bom posicionamento.

A próxima preocupação é como dispor os Beacons em si, tanto o dispositivo BT como o anfitrião do mesmo\footnote{ Como explicado em 5.1, um Beacon como um todo é constituído pelo dispositivo BT e pela máquina onde este está hospedado.}. O dispositivo BT deve estar no sítio planeado no passo anterior. É preciso aprovisionar sítios para os anfitriões e, talvez, os cabos necessários para ligar os dispositivos BT aos anfitriões (caso a ligação seja USB ou a antena do dispositivo seja externa).

Tendo os Beacons dispostos e instalados, falta ligá-los a uma rede \emph{ethernet}. Aqui, o maior inconveniente é ter de evitar o uso de WiFi. WiFi usa a mesma banda de frequências que o BT e pode interferir na localização, logo o seu uso deve ser minimizado.

O próximo passo é ligar o Central à rede \emph{ehternet} e arrancar o programa desta parte do sistema. Durante o arranque, o Central envia para o \emph{stdout} o endereço IP e porta TCP aonde vai esperar que os Beacons se liguem. O passo seguinte é correr o binário que contém a parte do Beacon do sistema em cada um dos Beacons, dando como argumento o IP e a porta TCP do Central.

Nesta altura, os Beacons começam o diálogo com o Central. Primeiro avisam que começaram uma sessão de funcionamento. Não muito depois, os Beacons devem começar a tirar medições de RSSI\_ACL da força de sinal com que se ``vêem'' uns aos outros, informando o Central dos valores.

Nesta altura, o sistema está pronto a localizar um Rover que entre na sua área de actuação.

\subsection{Funcionamento}


Se ligarmos um dispositivo BT reconhecido como Rover, eventualmente, os Beacons ligam-se a ele. Eventualmente porque um Beacon só pode tentar ligar-se a um Rover de cada vez e cada tentativa de ligação demora aproximadamente 5 segundos.

No melhor dos casos, os Beacons demoram 5 segundos a reconhecer a presença do Rover. No pior dos casos, demoram o número de Rovers registados multiplicado por cinco, em segundos. O valor máximo de espera por resposta de um Rover pode ser controlado. Com base em observações empíricas, abaixo dos 3 segundos, as ligações nem sempre se concretizam e acima de 5 segundos não temos aumento de conectividade numa área de 8 metros quadrados.

À medida que as ligações são efectuadas, retiradas medições do RSSI\_ACL e comunicado o seu valor ao Central, a interface gráfica vai mostrando as deduções feitas pelo Central. Quando três anéis se intersectam, é marcado na interface o centro geométrico da área de intersecção.

Inserir Printscreen das cenas em funcionamento.

\section{Comportamento e avaliação das estimativas}


Nos testes efectuados, os Beacons estavam dispostos num triângulo isósceles rectângulo, cada cateto com 2,5 metros.

Nos testes efectuados, o sistema, quase sempre, detectava com precisão quando o Rover se situava no centro geométrico do polígono formado pelos Beacons. À medida que o Rover se distanciava do centro, embora com menos sucesso, o sistema conseguia ``ver'' o sentido do deslocamento relativamente bem, mas não a quantidade do mesmo. Ou seja, o sistema sabia para que lado se mexeu o Rover, mas não o quanto se mexeu. As estimativas da amplitude do movimento eram sempre menores do que a amplitude real. Este desfasamento crescia à medida que o Rover se distanciava do centro.

Pelo comportamento observado, pode-se facilmente concluir que ignorar o andamento logarítmico do RSSI\_ACL ao longo da distância foi um erro. É de notar que, mesmo com esta falha, o protótipo consegue estimar minimamente a posição de um Rover. Isto evidencia algum progresso e dá segurança para investir mais estudo num sistema de radiolocalização passiva apoiada em BT.

\section{Trabalho futuro}


No fim da implementação, o estagiário sente que há dois campos que merecem atenção. Um deles é claramente o método de dedução da distância a partir da força de sinal. O outro é a qualidade do código de comunicação com o HCI.

O actual método de dedução da localização não considera a referida natureza logarítmica do andamento. Aqui, a solução mais simples é, durante a execução, efectuar a regressão logarítmica e determinar a função inversa. Com isto, temos um sistema de dedução da posição simples. O maior risco desta aproximação é o impacto do erro. Tento em conta que se trata duma função exponencial, é previsível que as margens de dúvida aumentem bastante.

Em relação à comunicação com o HCI, o estagiário considera que já houve demasiados enganos e mal entendidos no uso da framework. Tendo em conta que se adquiriu bastante experiência na interacção com o HCI, apostar em não usar nenhuma abstracção resultará num controlo preciso. Há só que considerar que a carga de trabalho aumenta bastante. 

\part{Conclusões}
\label{_Ref31804431}

Neste capítulo será sumariado o conhecimento adquirido ao longo do estágio.

A partir do trabalho realizado, podemos concluir que:
\begin{itemize}
\item Não introduzindo hardware ``exótico'', com o fraco suporte para inspecção do sinal da comunicação BT requerido pela especificação, a solução terá que se apoiar em extensões proprietárias do HCI;
\item Pragmaticamente, só há um ambiente onde podemos controlar o diálogo com o HCI, em \emph{Linux}, e a framework para esse efeito, \emph{BlueZ}, mesmo este não está apta para usos mais extremos;
\item Apoiando-nos na medida RSSI\_ACL, proprietária da CSR, aparenta haver a possibilidade de conseguir construir um sistema de localização de aparelhos BT por radiolocalização passiva com estimativas exactas e de precisão razoável (cerca de um metro).
\item Ignorar o andamento logarítmico do RSSI\_ACL ao longo da distância é um erro;
\end{itemize}
\end{enumerate}

Embora a experiência não tenha tido todos os resultados pretendidos, decorreu como esperado. Tendo em conta todas as anteriores tentativas falhadas por parte de outras pessoas, os objectivos estavam claramente ``inflacionados''. De todas as conclusões que o trabalho desenvolvido baseou, considera-se a mais importante é ter encontrado uma medida proporcionada pelo HCI com forte correlação com a distância. O protótipo, embora não funcione plenamente, dá alguns resultados consistentemente. Isto proporciona a sensação de que é possível melhorar as ideias e métodos actuais para conseguir os objectivos que, por hora, são vistos como demasiado ambiciosos.

\part{Referências e Bibliografia}


@Misc{WC:Radiolocalização,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://www.wavecom.pt/index.php?option=com_content&task=view&id=19&Itemid=34}",
}

@Misc{WC:Radiolocalização,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://www.wavecom.pt/index.php?option=com\_content\&task=view\&id=19\&Itemid=34}",
}


@Misc{WP:Position,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://en.wikipedia.org/wiki/Position}",
}


@Misc{WP:CoordinateSystem,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://en.wikipedia.org/wiki/Coordinate\_system}",
}


@Misc{WP:WGS,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://en.wikipedia.org/wiki/World\_Geodetic\_System}",
}


@Misc{WP:OndasDeRádio,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://pt.wikipedia.org/wiki/Ondas\_de\_rádio}",
}


@Misc{WP:RadioFrequency,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://en.wikipedia.org/wiki/Radio\_frequency}",
}


@Misc{WP:Radio,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://en.wikipedia.org/wiki/Radio}",
}


@Misc{WP:Navigation,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://en.wikipedia.org/wiki/Navigation}",
}


@Misc{WP:DeadReckoning,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://en.wikipedia.org/wiki/Dead_reckoning}",
}


@Misc{WP:Sextante,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://pt.wikipedia.org/wiki/Sextante}",
}


@Misc{WP:Triangulation,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://en.wikipedia.org/wiki/Triangulation}",
}


@Misc{WP:Trilateration,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://en.wikipedia.org/wiki/Trilateration}",
}


@Misc{WP:GPS,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://en.wikipedia.org/wiki/GPS}",
}


@Misc{MS:BluetoothStackArchitecture,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://msdn2.microsoft.com/en-us/library/ms863323.aspx}",
}


@Misc{MS:RADAR,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://research.microsoft.com/~bahl/MS_Projects/RadarDemo/default.asp}",
}


@Misc{MS:RADARDemo,
	author =	"Wavecom",
	title =		"Rádio-localização",
	howpublished =	"Website",
	note =	"\url{http://research.microsoft.com/~bahl/MS_Projects/RadarDemo/demo.htm}",
}


\part{ANEXO A:<Normas de Escrita do Relatório>}


<

O documento principal a que diz respeito este anexo define e exemplifica os formatos de texto a utilizar e propõe um exemplo de conteúdos. Devem ainda ser seguidas regras gerais de preparação de relatórios, tal como são propostas pela FEUP, ou em livros sobre o tema (por exemplo: \emph{{\footnotesize Sussams}}\emph{{\footnotesize , }}\emph{{\footnotesize John}}\emph{{\footnotesize  E., 1983: ``Como Fazer um Relatório'', Editorial Presença, 1996,114 pp., ISBN 972-23-1290-1}}).

O relatório final deverá ser encadernado segundo normas específicas a divulgar oportunamente no ``site'' dos estágios da LEIC. O Relatório e seus anexos devem ser apresentados, \textbf{em }\textbf{quadruplicado}, no Secretariado da LEIC.

Em vários pontos do documento utiliza-se a notação de símbolos `` <'' e ``>''. O texto delimitado por um destes pares de símbolos deve ser substituído por outro mais adequado. Por exemplo: 

\fbox{
\begin{minipage}{15.965011088035483cm}
\begin{center}
<\textbf{Título do Relatório do Estágio Curricular> na}\textbf{}\textbf{ <instituição}\textbf{ onde decorreu o estágio (Arial 14 Negrito)}>
\end{center}
\end{minipage}}

Deve dar lugar, por exemplo, a: 

\fbox{
\begin{minipage}{15.965011088035483cm}
\begin{center}
\textbf{Definição do Plano Director de Informática da IVM na }\textbf{Agência de Inovação SA}
\end{center}
\end{minipage}}



As páginas do documento, quer para o texto principal, quer para os anexos, são identificadas em numeração árabe, em sequência e sem interrupções. O número total de páginas não deve exceder as 100, devendo o texto principal limitarse a 80.

As primeiras páginas, até ao índice de conteúdos inclusive, identificam-se com numeração romana, em letras minúsculas.

A numeração de capítulo/secção é efectuada em sequência. Cada novo capítulo deve iniciar-se no topo de página, tal como exemplificado neste documento.

\section{Formatação do Texto}


Formatação do texto, estilo ``Normal'':
\begin{itemize}
\item Tipo de Letra: ``Times New Roman'', 12 pontos.
\item Parágrafo: espaçamento anterior 6 pontos, espaçamento a seguir 0 pontos, espaçamento entre linhas exactamente 15 pontos (excepto para inclusão de figuras ou outros objectos).
\end{itemize}

\section{Definição de Página}


Uma página, sempre de formato A4, deve respeitar as dimensões:
\begin{itemize}
\item Margens de página superior: 2,5 cm;
\item Margem inferior: 1,5 cm;
\item Margem esquerda: 3,0 cm;
\item Margem direita: 2,0 cm;
\item Cabeçalho a 1,25 cm da margem superior;
\item Rodapé a 1 cm da margem inferior.
\end{itemize}

\section{Anexos}


Em relação aos anexos, é de salientar o seguinte:
\begin{itemize}
\item A numeração de páginas dos anexos é feita na continuidade da numeração do texto principal.
\item Os últimos anexos, quando não caibam no número de páginas definido anteriormente, podem ser apresentados em documentos encadernados separadamente, devendo no entanto seguir as mesmas normas, em particular no que respeita à encadernação e à identificação na lombada.
\item Os programas desenvolvidos podem ser incluídos, como anexos, em suportes informáticos adequados.
\end{itemize}

>

\part{ANEXO B:<Título do Anexo B>}


<Continuar a utilizar a numeração das páginas do relatório. Não exceder as 100 páginas no total do Volume.>

\part{ANEXO C:<Título do Anexo C>}


<Continuar a utilizar a numeração das páginas do relatório. Não exceder as 100 páginas no total do Volume.>


\end{document}
